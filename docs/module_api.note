
# --------------------------------------------------------------------------- #
#                    M O D U L E   A P I   F O R   U S E R                    # 
# --------------------------------------------------------------------------- #


1. Log system: see doc about reading kernel logs


2. Data exchange system calls:  
   $ cat /proc/kallsyms | grep T | grep <symbol> 
        symbol:     'copy_to_user' or 'copy_from_user'
        header:      /lib/modules/`uname -r`/build/include/asm-generic/uaccess.h 
        comment:     interrupt-ctx-forbidden (disk operations if user memory page not in RAM)


3. Symbol devices names: /dev/<name>
   Module must implement interface: open(), read(), close(), write()


4. Files:
        /proc/...    pseudofiles; data is always in symbolic format, not binary
        /sys/....    modern interface similar to /proc/


5. Net interfaces: create new or modify existent


# --------------------------------------------------------------------------- #
#                           M O D U L E   D E S I G N                         # 
# --------------------------------------------------------------------------- #


Three key points:

        (1) How to register driver and notify system about new device is connected

        (2) How to create new /dev/ name and link it with major/minor device number

        (3) How to implement required API (open, close, ...)


# --------------------------------------------------------------------------- #
#                     ( 1 )   R E G I S T E R   D R I V E R                   # 
# --------------------------------------------------------------------------- #


Available approaches:

1. Using 'struct cdev' [see <linux/cdev.h>]

        >> static struct file_operations fops = { ... };		// file operations
        >> static struct cdev hcdev = { 0 };				// character device handler
    	>> cdev_init(&hcdev, &fops);					// always success
    	>> hcdev.owner = THIS_MODULE;					// 
	>> int ret = cdev_add(&hcdev, MKDEV(...), DEVICE_COUNT);	// negative ret means error

2. Misc drivers (miscellaneous)

        ...
        ...
        ...

3. Using 'register_chrdev()'

        ...
        ...
        ...


# --------------------------------------------------------------------------- #
#                     ( 2 )   / D E V /   I N T E R F A C E                   # 
# --------------------------------------------------------------------------- #


/dev/<device> is linked against particular module via combination of:
        - major number = device class
        - minor number = concrete device class instance. For every minor 
                         number one device node might be created and used as 
                         a separate device of device class (major number).

>> #include <linux/types.h>
>> #include <linux/kdev_t.h>
>> dev_t dev = <complex_value>;
>> int major = MAJOR(dev);              // retreive major value from complex
>> int minor = MINOR(dev);              // retreive minor value from complex

Approaches to set dev_t <complex_value> and register it:

>> dev = MKDEV(major, minor); 
>> alloc_chrdev_region(&dev, <device_count>, <device_name>);    		  // variant 1: automatically      
>> register_chrdev_region(dev, <device_first>, <device_count>, <device_name>);    // variant 2: manually 
>> unregister_chrdev_region(dev, <device_count>);				  // at the module work end unregister is necessary

[!] Don't confuse module name, device name and device node
[!]     [: module_name :]  -  /proc/modules - is used in Makefile and for module management (modprobe, rmmod, udev DEVPATH, ...)
[!]     [: device_name :]  -  /proc/devices - is name which will be used to register in and appear in uevents
[!]     [: device_node :]  -  /dev/... - is file which will linked against device major and minor values

After it we should choose approach of how will 
device with registered major and minor values be 
linked against /dev/<device> filename:

        - manually              $ mknod ...                             [see man 1 mknod]
        - automatically         sytemd daemon 'udev'                    [see man 7 udev]
        - automatically         class_create() + device_create()        [see https://www.kernel.org/doc/html/latest/driver-api/infrastructure.html]

And finally When module is linked against device node in /dev/<device>, 
such a module is named and considered as DEVICE DRIVER. Device unlinking
must be also done via the same mechanism as it was linked.

[!] It is not realy necessary to create device node in /dev/ directory. 
Every accessible directory with appropriate permissions is suitable: for 
example, node might be created in the directory of module compilation.

1. Manually: mknod

        Linking:
        
                > load module (insmod or modprobe)
                $ lsmod | grep <module>.ko                      // check if module is loaded
                $ cat /proc/devices | grep <device_name>        // check if module is registered as device         [: device_name :]
                $ mknod -m006 /dev/<device> c <major> <minor>   // link registered device against /dev/<device>    [: device_node :]

        Device removal must be performed in reverse order:

                $ rm /dev/<device>                              // unlink registered device from /dev/<device>
                > remove module (rmmod or modprobe)


2. Automatically: udev

        Udev is Linux-specific subsystem which handle device events:
        [see man 7 udev]
                - udev events are usually called 'uevents'
                - uevents are sent directly by kernel
                - triggers are: add device + remove device + device changes state
        
        Uenents are received via the Linux-specific AF_NETLINK protocol socket:
        [see man 8 systemd-udevd.service]
                - socket(AF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);
                - uevents are sent by kernel in broadcast mode
                - udevd daemon when running is one of possible receivers

        Udevd workflow:
        [: udev :]
                - receive event
                - look through *.rules files to match event info against rules
                - proceed rule which was found:  
                        step 1  =  check if rule suits (operators ==, !=)
                        step 2  =  if rule suits proceed assignment (operators =, +=, :=)
                        step 3  =  proceed operations related to assignments from step 2
                $ cat /usr/lib/udev/rules.d/50-udev-default.rules   // rules references

        [!] actual workflow is little bit more sophisticated because rules might override each 
            other so read manual pages before implementing complicated logic if its neseccary
        
        Managing device:
        [: device_node :]
                step 1  =  create file with rules: <priority>-<filename>.rules
                        to create device node, use script (which creats nodes) and  >> RUN+="<script>.sh" 
                        to create symlink to device node, use  >> SYMLINK+="<linkname>"
                step 2  =  place it to one of the valid paths, e.g.: /etc/udev/rules.d/
                step 3  =  $ systemctl restart udev  or  $ udevadm control --reload-rules
                step 4  =  load or remove module

        Observe or manage udev work is possible using udevadm:
        [see man 8 udevadm]
                $ udevadm monitor --property                // watch uevents in real time
                $ udevadm control --log-priority=debug      // get more log info, use `journalctl -xe`
                $ udevadm control --reload-rules            // apply *.rules changes without restarting
                $ udevadm info -q=all -p=<DEVPATH>          // get all info about loaded device


3. Automatically: class_create() + device_create()    [: device_class :]

        Device nodes might be created from inside source code.
        The kernel API for that:
                - struct class *                            // device class handler
                - class_create(), class_destroy()           // manage device class
                - device_create(), device_destroy()         // manage device class instances

        
# --------------------------------------------------------------------------- #
#                        ( 3 )   R E Q U I R E D   A P I                      # 
# --------------------------------------------------------------------------- #


Almost all useful work is done using structures:

>> #include <linux/fs.h>
>> struct file_operations = { ... };
>> struct inode_operations = { ... };

If handler function is specified it will be called for corresponding
operation. Otherwise either DAFAULT HANDLER will be called or specific
error 'not implemented yet' will be returned

Handler prototypes are mostly of the following template:

        file_operations   =  <type> (*<name>) (struct file *, <args>);
        inode_operations  =  <type> (*<name>) (struct inode *, <args>);

[!] The 'struct file *' argument is associated with particulatr file
    descriptor and therefore might differ from call to call as several
    file descriptors are allowed for the same device and all of them
    are unique. But 'struct inode *' is always the same as it's unique
