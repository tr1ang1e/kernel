
# --------------------------------------------------------------------------- #
#                    M O D U L E   A P I   F O R   U S E R                    # 
# --------------------------------------------------------------------------- #


1. Log system: see doc about reading kernel logs


2. Data exchange system calls:  
   $ cat /proc/kallsyms | grep T | grep <symbol> 
        symbol:     'copy_to_user' or 'copy_from_user'
        header:      /lib/modules/`uname -r`/build/include/asm-generic/uaccess.h 
        comment:     interrupt-ctx-forbidden (disk operations if user memory page not in RAM)


3. Symbol devices names: /dev/<name>
   Module must implement interface: open(), read(), close(), write()


4. Files:
        /proc/...    pseudofiles; data is always in symbollic format, not binary
        /sys/....    modern interface similar to /proc/


5. Net interfaces: create new or modify existent


# --------------------------------------------------------------------------- #
#                           M O D U L E   D E S I G N                         # 
# --------------------------------------------------------------------------- #


Three key points:

        (1) How to register driver and notify system about new device is connected

        (2) How to create new /dev/ name and link it with major/minor device number

        (3) How to implement required API (open, close, ...)


# --------------------------------------------------------------------------- #
#                     ( 1 )   R E G I S T E R   D R I V E R                   # 
# --------------------------------------------------------------------------- #


Available approaches:

1. Using 'struct cdev' [see <linux/cdev.h>]

        >> static struct file_operations fops = { ... };		// file operations
        >> static struct cdev hcdev = { 0 };				// cdev handler
    	>> cdev_init(&hcdev, &fops);					// always success
    	>> hcdev.owner = THIS_MODULE;					// 
	>> int ret = cdev_add(&hcdev, MKDEV(...), DEVICE_COUNT);	// negative ret is error

2. Misc drivers (miscellaneous)

        ...
        ...
        ...

3. Using 'register_chrdev()'

        ...
        ...
        ...


# --------------------------------------------------------------------------- #
#                     ( 2 )   / D E V /   I N T E R F A C E                   # 
# --------------------------------------------------------------------------- #


/dev/<device> is linked against particular module via combination of:
        - major number = device class
        - minor number = concrete device class instance

>> #include <linux/types.h>
>> #include <linux/kdev_t.h>
>> dev_t dev = <complex_value>;
>> int major = MAJOR(dev);              // retreive major value from complex
>> int minor = MINOR(dev);              // retreive minor value from complex

Approaches to set dev_t <complex_value> and register it:

>> dev = MKDEV(major, minor); 
>> alloc_chrdev_region(&dev, <device_count>, <device_name>);    		  // variant 1: automatically      
>> register_chrdev_region(dev, <device_first>, <device_count>, <device_name>);    // variant 2: manually 
>> unregister_chrdev_region(dev, <device_count>);				  // at the module work end unregister is necessary

After it we should choose approach of how will 
device with registered major and minor values be 
linked against /dev/<device> filename:

        - manually              $ mknod ...                             [see man 1 mknod]
        - automatically         sytemd daemon 'udev'                    [see man 7 udev]
        - automatically         class_create() + device_create()        [see https://www.kernel.org/doc/html/latest/driver-api/infrastructure.html]

And finally When module is linked against device name in /dev/<device>, 
such a module is named and considered as DEVICE DRIVER. Device unlinking
must be also done via the same mechanism as it was linked.

[!] It is not realy necessary to create device node in /dev/ directory. 
Every accessible directory with appropriate permissions is suitable: for 
example, node might be created in the directory of module compilation.

1. Manually: mknod

        Linking:
        
                > load module (insmod or modprobe)
                $ lsmod | grep <module>.ko                      // check if module is loaded
                $ cat /proc/devices | grep <device_name>        // check if module is registered as device
                $ mknod -m006 /dev/<device> c <major> <minor>   // link registered device against /dev/<device>

        Device removal must be performed in reverse order:

                $ rm /dev/<device>                              // unlink registered device from /dev/<device>
                > remove module (rmmod or modprobe)

2. Automatically: udev    [: udev :]


3. Automatically: class_create() + device_create()

        
# --------------------------------------------------------------------------- #
#                        ( 3 )   R E Q U I R E D   A P I                      # 
# --------------------------------------------------------------------------- #


Almost all useful work is done using structures:

>> #include <linux/fs.h>
>> struct file_operations = { ... };
>> struct inode_operations = { ... };

If handler function is specified it will be called for corresponding
operation. Otherwise either DAFAULT HANDLER will be called or specific
error 'not implemented yet' will be returned

Handler prototypes are mostly of the following template:

        file_operations   =  <type> (*<name>) (struct file *, <args>);
        inode_operations  =  <type> (*<name>) (struct inode *, <args>);

[!] The 'struct file *' argument is associated with particulatr file
    descriptor and therefore might differ from call to call as several
    file descriptors are allowed for the same device and all of them
    are unique. But 'struct inode *' is always the same as it's unique
