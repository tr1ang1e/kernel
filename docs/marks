
# --------------------------------------------------------------------------- #
#                       N O T   C A T E G O R I Z E D                         # 
# --------------------------------------------------------------------------- #    


# --------------------------------------------------------------------------- #
#                       M O D U L E   M A N A G E M E N T                     # 
# --------------------------------------------------------------------------- #


1. Information

    $ modinfo <module>.ko                       // show information about a module
    $ objdump <module>.ko [ -h ... ]            // information from object files
    $ readelf <module>.ko [ -s ... ]            // display information about ELF files
    $ lsmod | grep <module>                     // show the status of module in the kernel

2. Management

    A. Without checking dependencies
        $ insmod <module>.ko                    // insert a module into the kernel
        $ rmmod <module>                        // remove a module from the kernel

    B. With checking dependencies
        $ cp <module>.ko /lib/modules/`uname -r`/...
        $ depmod -a                             // update dependencies [see man 8 depmod]
        $ modprobe <module>                     // insert a module into the kernel after insertion all dependencies

    C. Autoload: static, while boot
        > do step B.                            // autoload is modprobe related feature 
        > create /etc/modules-load.d/...        // [see man 8 systemd-modules-load.service and man 5 modules-load.d]

    D. Autoload: dynamic                        // [?] [see man 7 udev] 

3. Blacklist 

    > create /etc/modprobe.d/...                // [see man 5 modprobe.d]
    > insert 'blacklist <module>'               // [see man 5 modprobe.d]


# --------------------------------------------------------------------------- #
#           M O D U L E   v s   K E R N E L   I N T E R A C T I O N           # 
# --------------------------------------------------------------------------- #


1. System calls

    All symbols which are defined in kernel are listed in /proc/kallsyms.
    File format: 
        (absolute address) (type [see man nm]) (name)

    Get info from file
        $ cat /proc/kallsyms                  // all symbols
        $ cat /proc/kallsyms | grep " T "     // filter only exported

2. Error codes

    header:      /lib/modules/`uname -r`/build/include/uapi/asm-generic/errno*
    comment:     always negative when returning from kernel (-EPERM instead of EPERM)


# --------------------------------------------------------------------------- #
#                    M O D U L E   A P I   F O R   U S E R                    # 
# --------------------------------------------------------------------------- #


1. Log system: see 'LOGS READING' section below

2. Data exchange system calls:  
   $ sudo cat /proc/kallsyms | grep T | grep <symbol> 
        symbol:     'copy_to_user' or 'copy_from_user'
        header:      /lib/modules/`uname -r`/build/include/asm-generic/uaccess.h 
        comment:     interrupt-ctx-forbidden (disk operations if user memory page not in RAM)

3. Symbol devices names: /dev/<name>
   Module must implement interface: open(), read(), close(), write()

4. Files:
        /proc/...    pseudofiles; data is always in symbollic format, not binary
        /sys/....    modern interface similar to /proc/

5. Net interfaces: create new or modify existent


# --------------------------------------------------------------------------- #
#                           L O G S   R E A D I N G                           # 
# --------------------------------------------------------------------------- #


How logs are processed:
    1. printk() -> kernel logs ring buffer
    2. system log daemon (`ps -A | grep logd`) interacts with ring bffer interface (/proc/kmesg)
    3. system log daemon -> to user (system log, text console, ...) 

Current system log daemon [man 8 rsyslogd]
    > config:
        $ nano /etc/rsyslog.conf                    // main config
        $ nano /etc/rsyslog.d/<name>.conf           // custom config
    $ cat /etc/systemd/system/syslog.service        // systemd service unit
    $ systemctl status rsyslog                      // current status
    $ systemctl restart rsyslog                     // restart (to apply new conf)

RPI kernel logs:	
    $ dmesg 		                                // only logs from kernel log buffer
    $ tail -f /var/log/kern.log	                    // only logs from kernel log buffer
    $ tail -f /var/log/messages		                // different logs including kernel logs

RPI boot logs
    $ cat /var/log/boot.log


# --------------------------------------------------------------------------- #
#              D E V E L O P M E N T   E N V I R O N M E N T                  # 
# --------------------------------------------------------------------------- #    


0. Bring OS to appropriate state 
   [https://www.raspberrypi.com/documentation/computers/os.html#updating-and-upgrading-raspberry-pi-os]

    $ apt update
    $ apt full-upgrade

1. Build tools

    $ sudo apt install build-essential
    $ gcc --version
    $ make --version

2. Linux kernel artifacts for out-of-tree kernel modules

    [!] Bullseye Linux distro, others might differ
    $ apt-cahe search raspberrypi                   // list all pakages just for reference
    $ apt install raspberrypi-kernel-headers        // install all neseccary for current kernel oot-modules development
    
    // Verification steps
    $ apt show raspberrypi-kernel-headers           // verify installation info
    $ ls -l /lib/modules/`uname -r`/build           // verify simlink is created
    $ tree -L 1 /lib/modules/`uname -r`/build       // verify directories tree
    $ find / -name Module.symvers                   // verify file with all the exported kernel symbols

    [!] For building in-kernel modules special approach is required [https://github.com/RPi-Distro/rpi-source]

    [?] How to build oot-kernel modules for:
        - kernel not running on current device or
        - using toolchain for cross-compile on another distro?
    
    [?] How does building from source affect building oot-kernel modules development?
        Can we use all the headers and exported kernel symbols from kernel build tree?
